// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'protocol.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`

String getTargetDeviceName() =>
    RustLib.instance.api.crateApiProtocolGetTargetDeviceName();

ParseResult parseCharacteristicData({
  required ScooterState state,
  required String uuid,
  required List<int> data,
}) => RustLib.instance.api.crateApiProtocolParseCharacteristicData(
  state: state,
  uuid: uuid,
  data: data,
);

Uint8List createCommandBytes({
  required ScooterCommand command,
  required ScooterState currentState,
}) => RustLib.instance.api.crateApiProtocolCreateCommandBytes(
  command: command,
  currentState: currentState,
);

BleAction getCommandAction({
  required ScooterCommand command,
  required ScooterState currentState,
}) => RustLib.instance.api.crateApiProtocolGetCommandAction(
  command: command,
  currentState: currentState,
);

class BleAction {
  final Uint8List bytes;
  final String serviceUuid;
  final String characteristicUuid;

  const BleAction({
    required this.bytes,
    required this.serviceUuid,
    required this.characteristicUuid,
  });

  @override
  int get hashCode =>
      bytes.hashCode ^ serviceUuid.hashCode ^ characteristicUuid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BleAction &&
          runtimeType == other.runtimeType &&
          bytes == other.bytes &&
          serviceUuid == other.serviceUuid &&
          characteristicUuid == other.characteristicUuid;
}

class ParseResult {
  final ScooterState state;
  final String? log;

  const ParseResult({required this.state, this.log});

  @override
  int get hashCode => state.hashCode ^ log.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ParseResult &&
          runtimeType == other.runtimeType &&
          state == other.state &&
          log == other.log;
}

@freezed
sealed class ScooterCommand with _$ScooterCommand {
  const ScooterCommand._();

  const factory ScooterCommand.togglePower() = ScooterCommand_TogglePower;
  const factory ScooterCommand.toggleAlarm() = ScooterCommand_ToggleAlarm;
  const factory ScooterCommand.toggleSport() = ScooterCommand_ToggleSport;
  const factory ScooterCommand.toggleLights() = ScooterCommand_ToggleLights;
  const factory ScooterCommand.cruiseUp() = ScooterCommand_CruiseUp;
  const factory ScooterCommand.cruiseDown() = ScooterCommand_CruiseDown;
  const factory ScooterCommand.horn() = ScooterCommand_Horn;
  const factory ScooterCommand.setUart(String field0) = ScooterCommand_SetUart;
}

class ScooterState {
  final bool powerOn;
  final bool alarmOn;
  final bool sportOn;
  final bool lightsOn;
  final bool hornActive;
  final String speed;
  final String throttleLevel;
  final String temperature;
  final String clockMinutes;
  final String clockHours;
  final int cruiseLevel;
  final String batteryLevel;
  final String batteryPower;
  final bool brakeActive;
  final bool parkBrakeActive;
  final String odometer;

  const ScooterState({
    required this.powerOn,
    required this.alarmOn,
    required this.sportOn,
    required this.lightsOn,
    required this.hornActive,
    required this.speed,
    required this.throttleLevel,
    required this.temperature,
    required this.clockMinutes,
    required this.clockHours,
    required this.cruiseLevel,
    required this.batteryLevel,
    required this.batteryPower,
    required this.brakeActive,
    required this.parkBrakeActive,
    required this.odometer,
  });

  static Future<ScooterState> default_() =>
      RustLib.instance.api.crateApiProtocolScooterStateDefault();

  @override
  int get hashCode =>
      powerOn.hashCode ^
      alarmOn.hashCode ^
      sportOn.hashCode ^
      lightsOn.hashCode ^
      hornActive.hashCode ^
      speed.hashCode ^
      throttleLevel.hashCode ^
      temperature.hashCode ^
      clockMinutes.hashCode ^
      clockHours.hashCode ^
      cruiseLevel.hashCode ^
      batteryLevel.hashCode ^
      batteryPower.hashCode ^
      brakeActive.hashCode ^
      parkBrakeActive.hashCode ^
      odometer.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScooterState &&
          runtimeType == other.runtimeType &&
          powerOn == other.powerOn &&
          alarmOn == other.alarmOn &&
          sportOn == other.sportOn &&
          lightsOn == other.lightsOn &&
          hornActive == other.hornActive &&
          speed == other.speed &&
          throttleLevel == other.throttleLevel &&
          temperature == other.temperature &&
          clockMinutes == other.clockMinutes &&
          clockHours == other.clockHours &&
          cruiseLevel == other.cruiseLevel &&
          batteryLevel == other.batteryLevel &&
          batteryPower == other.batteryPower &&
          brakeActive == other.brakeActive &&
          parkBrakeActive == other.parkBrakeActive &&
          odometer == other.odometer;
}
